# 第二章 数据类型

在 [第一章 入门](./001-入门.md) 中我们学习了 C 语言的基本构成要素。其中，最基本的要素就是 **对象**，即 **表示值的一块存储区域**。更准确的说，**执行环境中数据存储区域，其内容可用于表示值**。此外，**对象在被引用时，具有特定的类型**

![1769615781279.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769615781317.png)

对象通过 **名字** 进行引用，通过名字可以访问对象的值，以及修改对象的值。要使用名字引用对象，就必须先 **声明** 这个名字。声明时需要提供名字的 **类型**，这个类型告诉我们对象的值时什么种类的。例如，`int` 类型的对象包含的是整数值

> [!tip]
> 
> 类型的重要之处在于，如果将表示某一种对象类型的位模式按照另一种对象类型来解释，则可能产生不同的值

例如，数值 $1$，在 IEEE 754 单精度浮点数中是按照位模式 $(3f800000)_{16}$ 表示的。如果将这个位模式解释为整数，那么得到的结果是 $1\ 065\ 353\ 216$。

## 2.1 基本类型

C 语言中的基本类型涉及布尔类型、字符类型和数值类型。其他类型都是基于它们派生的。

### 2.1.1 布尔类型

最初的 C 语言并没有提供布尔类型，然而许多程序需要变量存储代表 **真(true)** 或 **假(false)** 的逻辑值。因此，通常使用 `int` 类型的变量来存储逻辑值，数值 $0$ 表示 `false`，任何非零值都表示 `true`

```c
int flag;

flag = 0;  // 表示 false
...
flag = 1;  // 表示 true
```

这样的代码对无法为阅读代码的人员提供任何有效的信息，并且也没有限制变量 `flag` 只能被赋予布尔值，也没有明确的指明使用 $0$ 表示 `false`，$1$ 表示 `true`

为了提高程序可读性，通常会定义两个 `true` 和 `false` 两个宏，并且添加一个 `int` 类型的别名 `bool`

```c
#define true 1
#define false 0

typedef int bool;
```

从 C99 开始，布尔类型正式被引用，使用类型类型标识为 `_Bool`，并提供了头文件 `<stdbool.h>`，这个头文件只是简单的将 `_Bool` 重命名为 `bool`，并且定义了 `true` 和 `false` 两个宏。对于使用 C99 及其之后标准的程序员，可以在代码中包含 `<stdbool.h>` 之后，使用 `bool` 来声明布尔类型的变量，并使用 `true` 和 `false` 为其赋值

```c
#include <stdbool.h>  // C99 之后的版本

bool flag = false;
...
flag = true;
```

值得期待的是，从 C23 标准开始，废弃了头文件 `<stdbool.h>`，并将 `bool`、`true` 和 `false` 作为 C 语言的关键字

```c
bool flag = false;
...
flag = true;
```

### 2.1.2 整数类型

**整数类型** 将位模式映射成整数，详细内容参考 [第一章 入门](001-入门.md#16-信息存储) 中介绍的内容。C 语言中的整数类型分为 **有符号** 和 **无符号** 两种，它们分别对应 [第一章 入门#补码编码](001-入门.md#162-补码编码) 和  [第一章 入门#无符号整数](001-入门.md#161-无符号整数) 两种映射。使用关键字 `signed` 表示有符号整数， `unsigned` 表示符号整数

C 语言的整数类型有不同的大小，即位模式的长度。例如，`int` 类型通常是 $32$ 位，但是在一些旧平台上可能是 $16$ 位。有些程序需要使用非常大的整数，`int` 类型无法存储，所以，C 语言还提供了 `long int` 类型；有些程序需要的整数范围又非常小，出于节省空间的目的，C 语言还提供了 `short int`

> [!tip]
>
> 默认情况下，所有的整数都是有符号整数。如果需要表示无符号整数，则必须在类型标识符中加上 `unsigned` 关键字
>
> 例如，`unsigned int` 无符号整数，`unsigned short int` 无符号短整数

C99 标准引入了两个额外标准整数类型：`long long int` 和 `unsigned long long int`。增加它们的目的是 **为了满足日益增长的对超大型整数的需求** 和 **适应支持 64 位运算的新处理器的能力**。它们要求至少使用 $64$ 位位模式表示。下表列出了 C99 标准中的整数类型在不同平台上的尺寸

| 类型标识符                    | 等效类型                     | C 标准   | Win16 API | Win32 API/Unix | Win64 API | Unix |
| ------------------------ | ------------------------ | ------ | --------- | -------------- | --------- | ---- |
| `char`                   | `char`                   | $>=8$  | $8$       | $8$            | $8$       | $8$  |
| `signed char`            | `signed char`            |        |           |                |           |      |
| `unsigned char`          | `unsigned char`          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `short`                  | `short int`              | $>=16$ | $16$      | $16$           | $16$      | $16$ |
| `short int`              |                          |        |           |                |           |      |
| `signed short`           |                          |        |           |                |           |      |
| `signed short int`       |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `unsigned short`         | `unsigned short int`     |        |           |                |           |      |
| `unsigned short int`     |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `int`                    | `int`                    | $>=16$ | $16$      | $32$           | $32$      | $32$ |
| `signed`                 |                          |        |           |                |           |      |
| `signed int`             |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `unsigned`               | `unsigned int`           |        |           |                |           |      |
| `unsigned int`           |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `long`                   | `long int`               | $>=32$ | $32$      | $32$           | $32$      | $64$ |
| `long int`               |                          |        |           |                |           |      |
| `signed long`            |                          |        |           |                |           |      |
| `signed long int`        |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `unsigned long`          | `unsigned long int`      |        |           |                |           |      |
| `unsigned long int`      |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `long long`              | `long long int`          | $>=64$ | $64$      | $64$           | $64$      | $64$ |
| `long long int`          |                          |        |           |                |           |      |
| `signed long long`       |                          |        |           |                |           |      |
| `signed long long int`   |                          |        |           |                |           |      |
|                          |                          |        |           |                |           |      |
| `unsigned long long`     | `unsigned long long int` |        |           |                |           |      |
| `unsigned long long int` |                          |        |           |                |           |      |

> [!tip]
>
> 请注意，C 语言中 `char` 类型用于存储一个字符，至少占用 $8$ 位。然而，几乎所有的平台都将 `char` 类型实现为 $8$ 位位模式

这些标准类型在不同的平台上可能采用不同长度的位模式进行编码。从 C23 标准开始，引入了 `[signed] _BitInt(n)` 类型，它表示位模式长度为 $n$ 的有符号整数，其中 `n` 是一个整数类型的常量表达式。当然，`unsigned _BitInt(n)` 表示位模式长度为 $n$ 的无符号整数

#### 整数字面值

C 标准中定义了 $4$ 种格式的整数字面值，其中二进制格式是从 C23 标准引入的

| 格式       | 表示方式                                                        |
| -------- | ----------------------------------------------------------- |
| 二进制(C23) | <code>"0" ("b" \| "B") ("0" \| "1")+</code>                 |
| 八进制      | <code>"0" (0" ... "7")+</code>                              |
| 十进制      | <code>("1" ... "9"){1} ("0" ... "9")+</code>                |
| 十六进制     | <code>"0" ("x" \| "X") ("0" ... "9" \| "A" ... "F")+</code> |
例如，下面列出了整数字面值的常见表示形式

```c
// 十进制格式
2147483647
// 二进制格式
0b100110111
// 八进制格式
0377
// 十六进制格式
0xdeadbeef
```

C 语言中的整数字面值都有一个类型。默认情况下，编译器按照下面的方式确定整数字面值的类型

+ 十进制字面值：编译器依次尝试 `int -> long int -> long long int`，能够存储并且尺寸最小的类型就是字面值的类型

+ 二进制，八进制和十六进制字面值： 编译器依次尝试 `int -> unsigned int -> long int -> unsigned long int -> long long int -> unsigned long long int`，能够存储并且尺寸最小的类型就是字面值的类型

当然，也可以使用整数字面值 **后缀** 显示指定整数字面值类型。下表列出了可用的后缀

| 后缀   | 类型              |
| ---- | --------------- |
| `U`  | `unsigned int`  |
| `L`  | `long int`      |
| `LL` | `long long int` |

> [!warning] 
> 
> 注意，`U` 可以与 `L` 和 `LL` 结合使用。例如，`UL` 表示 `unsigned long int`; `ULL` 表示 `unsigned long long int`。当然，这些后缀也可以是小写的，但是，不建议使用小写的后缀

从 C23 标准开始，整数字面值可以使用单引号(`'`) 进行分隔，从而提高字面值的可读性

```c
int bin  = 0b111111010; // 二进制
int oct   = 0772;       // 八进制
int dec   = 506;        // 十进制
int hex   = 0x1fa;      // 十六进制

// 后缀
unsigned int uint = 506U;  
unsigned long ulint = 123456789UL;  

// C23 标准起，才能使用分隔符
unsigned long long ullint = 123'456'789ULL; 
```

### 2.1.3 浮点数类型

有些时候需要变量能存储 **带小数点的数**，或者能存储 **极大数** 或 **极小数**。这类数可以用 **浮点** 格式进行存储。C 语言提供了 $3$ 种浮点类型，对应三种不同的浮点格式

| 类型        	| 描述           	|
|-------------	|----------------	|
| `float`       	| 单精度浮点数   	|
| `double`      	| 双精度浮点数   	|
| `long double` 	| 扩展精度浮点数 	|

C 标准没有说明这些浮点类型提供的精度到底是多少，因为 **不同计算机可以用不同方法存储浮点数**。下表列出了这些浮点类型在支持 **IEEE 754 标准** 的计算机中采用的浮点格式，以及 **精度**，这里的精度是指尾数的位数

| 类型        	| 描述                                                   	|
|-------------	|--------------------------------------------------------	|
| `float`       | IEEE-754 binary32 格式：提供 $7$ 位有效数字的精度           |
| `double`     	| IEEE-754 binary64 格式：提供 $15$ 位有效数字的精度          |
| `long double`	| [IEEE-754 binary128 格式](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format) |
#### 浮点数字面值

C 语言中的浮点字面值必须包含 **小数点** 或 **指数**；其中，指数指明了对前面的数进行缩放所需的 
$10$ 的幂次。下面这些字面值全都是表示数 $57.0$ 的有效方式

```c
57.0
57.  
57.0e0
57E0
5.7e1
5.7e+1
.57e2
570.e-1
```

其中，`{a}E{b}` 表示浮点数值是 $a \times 10^{b}$。默认情况下，这些浮点数的类型都是 `double` 类型。如果需要，可以附加下表列出的后缀，从而指定字面值的类型

| 后缀  	| 类型          	|
|-------	|---------------	|
| `F`   	| `float`       	|
| `L`   	| `long double`    	|

因此，为了说明字面值常量必须以 `float` 格式存储，就必须添加后缀 `F`（`57.0F`）。为了说明常量必须以 `long double` 格式存储，可以在常量的末尾处加上字母 `L`（如 `57.0L`）

### 2.1.4 字符类型

唯一基本类型是 `char` 类型，即 **字符类型**。`char` 类型的值根据计算机使用的 **字符集** 的不同而不同，因为不同的机器可能会有不同的字符集

> [!tip]
>
> 所谓的 **字符集** 就是有一系列位模式组成的集合，其中每个位模式都表示一个特定的字符。详细请参阅 [第一章 入门#字符编码](001-入门.md#164-字符编码)

当初在标准化 C 语言的时候，尚没有普遍接受的字符编码，因此语言被设计为能够处理多种字符表示。每种 C 语言实现都会定义 **源字符集** 和 **执行字符集**。其中，源字符集用于书写 C 语言代码。源字符集和执行字符集必须包含以下字符

+ 拉丁字母表的大小写字母
+ $10$ 个十进制数字
+ $29$ 个图形字符、空格、水平制表符、垂直制表符、馈页符和换行符

目前最常用的字符编码包括 ASCII 和 Unicode，在 [第一章 入门#字符编码](001-入门.md#164-字符编码) 中已经详细介绍。关于 ASCII 编码，其中有几个特殊字符的编码需要特别记忆

- 字符 `' '`(空格) 编码的十进制表示为 $32$，十六进制表为 `0x20`
- 字符 `'0'` 编码的十进制表示为 $48$，十六进制表示为 `0x30`
- 字符 `'1'` 编码的十进制表示为 $49$，十六进制表示为 `0x31`
- 字符 `'A'` 编码的十进制表示为 $65$，十六进制表示为 `0x41`
- 字符 `'a'` 编码的十进制表示为 $97$，十六进制表示为 `0x61`

在 C 语言中存在这样一个事实：**字符可以当作小整数进行处理**。毕竟所有字符都是以位模式进行编码的，因此可以将这些位模式看成整数。

> [!tip]
>
> 几乎所有的平台的 C 语言实现都将 `char` 类型实现为 $8$ 位模式。也就是说，`char` 类型通常用于存储 ASCII 字符编码

既然 C 语言把字符作为整数来使用，那么 `char` 类型应该和整数一样存在 **有符号** 和 **无符号** 两种字符类型，即 `signed char` 和 `unsigned char`。请注意，C 标准并未规定 `char` 是 `signed char` 或者 `unsigned char`，因此我们需要将它们视为不同的三种类型。换句话说，**不能假设 `char` 类型的符号**

> [!tip]
>
> 当需要使用 `char` 类型存储小整数时，请明确使用 `signed char` 或者是 `unsigned char`

请注意，标准的 `char` 类型只能用于处理长度为 $1$ 字节的位模式的字符集，例如 ASCII 字符集。对于像 Unicode 这种多字节编码的字符集，`char` 类型是没有能力进行处理的

C99 标准开始，引入了 `wchar_t` 类型用于处理宽字符集。它的尺寸由具体实现定义，通常占 $2$ 字节。因此，我们可以使用 `wchar_t` 存储占用字节超过 $1$ 的字符，称为 **宽字符**

> [!tip]
>
> 类型 `wchar_t` 在头文件 `<wchar.h>` 中定义，本质上是整数类型
>

随着绝大多数系统使用的 Unicode 字符，目前 `wchar_t` 也是用于存储 Unicode 代码点。然而，C 语言没有规定 `wchar_t` 类型的长度，再加上不同的操作系统使用不同的 Unicode 编码方案（UTF），这就影响了文本的交换以及程序的可移植性

C11 标准起，标准库提供了 `<uchar.h>` 头文件，并且明确定义了两种具有明确长度的宽字符类型，它们分别是 `char16_t` 和 `char32_t `

- `char16_t` 是一个无符号整数类型，用来保存长度为 $16$ 位的字符，通常用于保存 UTF-16 编码的字符
- `char32_t` 也是一个无符号整数类型，用来保存长度为 $32$ 位的字符，通常用于保存 UTF-32 编码的字符

---

<center style="font-size:18px">字符字面值</center>

下表列出了字符类型的字面值语法

| 语法            | 类型         | 描述                                             |
| :------------ | ---------- | ---------------------------------------------- |
| `'c-char'`    | `int`      | **源字符集** 中的字符，除了 `'` `\`；或者 **转义序列**       |
| `u'c-char'`   | `char16_t` | 通常为 UTF-16 字符，例如 `u'猫'`                        |
| `U'c-char'`   | `char32_t` | 通常为 UTF-32 字符，例如 `U'猫'`                        |
| `L'c-char'`   | `wchar_t`  | 宽字符常量，例如 `L'β'` 或 `L'字'`                       |

字符集中往往存在许多非打印字符，下表列出了 C 语言中定义了一个 **转义序列** 用于表示非打印字符。

|名称|转义序列|
|:---|:---|
|响铃|`\a`|
|回退|`\b`|
|换页|`\f`|
|换行|`\n`|
|回车|`\r`|
|水平制表符|`\t`|
|垂直制表符|`\v`|
|反斜杠|`\\`|
|问号|`\?`|
|单引号|`\'`|
|双引号|`\"`|

这些转义序列使用起来很容易，但是它们有一个问题：转义序列列表没有包含所有非打印的 ASCII 字符，只包含了最常用的字符。为了表示所有的非打印字符，C 标准定义了 **数字转义序列**。

|名称|转移序列|
|:---|:-----|
|八进制转义序列|`\0oo0`|
|十六进制|`\xhh`|


以下示例代码演示了各种字符类型

```c title="chars.c"
#include <stddef.h>
#include <stdio.h>
#include <uchar.h>

int main(void) {
    printf("constant    value     \n");
    printf("--------    ----------\n");

    // 整数字符常量
    int c1 = 'a';
    printf("'a':\t %#010x\n", c1);
    int c2 = '🍌';
    printf("'🍌':\t %#010x\n\n", c2); // 实现定义

    // 多字符常量
    int c3 = 'ab';
    printf("'ab':\t %#010x\n\n", c3); // 实现定义

    // 16 位宽字符常量
    char16_t uc1 = u'a';
    printf("'a':\t %#010x\n", (int) uc1);
    char16_t uc2 = u'¢';
    printf("'¢':\t %#010x\n", (int) uc2);
    char16_t uc3 = u'猫';
    printf("'猫':\t %#010x\n", (int) uc3);

    // 实现定义（🍌 映射到二个 16 位宽字符）
    char16_t uc4 = u'🍌';
    printf("'🍌':\t %#010x\n\n", (int) uc4);

    // 32 位宽字符常量
    char32_t Uc1 = U'a';
    printf("'a':\t %#010x\n", (int) Uc1);
    char32_t Uc2 = U'¢';
    printf("'¢':\t %#010x\n", (int) Uc2);
    char32_t Uc3 = U'猫';
    printf("'猫':\t %#010x\n", (int) Uc3);
    char32_t Uc4 = U'🍌';
    printf("'🍌':\t %#010x\n\n", (int) Uc4);

    // 宽字符常量
    wchar_t wc1 = L'a';
    printf("'a':\t %#010x\n", (int) wc1);
    wchar_t wc2 = L'¢';
    printf("'¢':\t %#010x\n", (int) wc2);
    wchar_t wc3 = L'猫';
    printf("'猫':\t %#010x\n", (int) wc3);
    wchar_t wc4 = L'🍌';
    printf("'🍌':\t %#010x\n\n", (int) wc4);
}
```


## 2.2 声明变量



## 2.3 指针类型


## 2.4 函数类型


