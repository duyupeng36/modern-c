# 第四章 数组和循环

到目前为止，我们使用的变量都只是 **标量**（保存单一数据项的能力）。C 语言也支持 **聚合** 变量，这类变量可以存储成组的数值。C 语言提供两种聚合类型，分别是 **数组** 和 **结构体**。本章我们会优先介绍数组


## 4.1 数组

**数组** 表示一系列连续的内存空间的变量，每个内存空间可以存储相同类型的数据项。这些数据项称为 **元素**，以根据元素在数组中所处的位置把它们一个个地选出来

假设要编写一个程序统计一年温度的中有多少高于当年的平均温度，这样就必须记录一年中每天的温度。如果每天的温度都使用一个变量存储，程序会很繁琐，并且没有任何可行性。使用数组就可以轻松解决。例如，下面的语句声明了一个长度为 $366$ 元素为 `double` 类型的数组

```c
double temperatures[366];  // 长度为 366 元素为 double 的数组
```

请注意，数组的长度是数组类型的一部分，数组声明一旦确定，其长度就不允许发生改变。也就是说，在声明数组时，数组元素的个数必须使用 **整型常量表达式**，编译器在编译时能够计算的任何整型表达式都可以。

使用一个整数可以引用数组元素，把该整数称为数组元素的索引。**数组元素的索引是指该元素与数组第一个元素的偏移值**。第一个元素的偏移值是 $0$，因此其索引是 $1$；索引值为 $3$ 表示数组中的第 $4$ 个元素，与第一个元素偏移 $3$ 个元素。要引用数组元素，只需要在数组名后面的方括号中放上元素的索引值即可。例如，要把 `temperatures` 数组的第 $4$ 个元素设置为 $99.0$，可以使用下面的语句

```c
temperatures[3] = 99.0;
```

为了更好的使用图形演示数组元素，让我们定义另一个数组

```c
unsigned int height[6];
```

这条语句被执行时，编译器为这 $6$ 个 `unsigned int` 类型的值分配 $6$ 个连续的存储位置。`height` 数组中的每个元素都包含不同的值，由于定义是没有初始化，`height` 数组的每个元素其实都是垃圾值。下面的语句定义了带初始化的数组

```c
unsigned int height[6] = {26, 37, 47, 55, 62, 75};
```

数组的初始化列表包含 $6$ 个值，每个数组元素按顺序被赋予列表中的一个初始值。下表演示了数组 `height` 的每个元素的值

![1772379976588.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-03/1772379976603.png)

> [!tip]
>
> 注意，数组元素的类型决定了存储每个元素需要的内存量。数组的所有元素都存储在一个连续的内存中。

初始化数组时，如果初始化列表中的元素个数小于数组的长度，则没有提供初始值的元素统统被初始化为 $0$

```c
unsigned int height[6] = {26, 37, 47};
// [26, 37, 47, 0, 0, 0]
```

根据这个特性，我们可以很方便的将数组的所有元素都初始化为 $0$

```c
unsigned int height[6] = {0};
unsigned int height[6] = {};  // c23 起，将所有元素初始化为 0
```

> [!warning]
>
> 警告，数组初始化列表中的元素个数一定不能超过数组的长度，否则将会出现编译错误

在提供初始化列表的前提下，编译器应该知道初始化列表中的元素个数，因此可以让编译器根据初始化列表自动决定数组元素的个数

```c
unsigned int height[] = {26, 37, 47, 55, 62, 75};
// 自动推断数组 height 的长度为 6
```

使用初始化列表只能按顺序初始化数组元素，当需要初始化一个元素比较多，但是只有特定几个元素被初始化时，初始化列表写起来就非常麻烦。为了解决这个问题，C99 标准定义了 **指示器** 语法

```c
unsigned int height[6] = {[1] = 37, [3] = 55 };
// [0, 37, 0, 55, 0, 0]
```

有时候，我们希望数组中的元素值不能被修改，与定义只读变量一样，只需要在类型前面加上 `const` 关键字即可

```c
const unsigned int height[6] = {26, 37, 47, 55, 62, 75};
// const unsigned int 用于说明数组元素的类型
// 因此，height 数组元素是只读的，不能修改
```

任意试图修改这 $6$ 个元素的表达式都将被编译器检查出来，并提示编译错误

## 4.2 for 循环



