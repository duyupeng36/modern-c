# 第二章 基本数据类型

在 [第一章 入门](./001-入门.md) 中我们学习了 C 语言的基本构成要素。其中，最基本的要素就是 **对象**，即 **表示值的一块存储区域**。更准确的说，**执行环境中数据存储区域，其内容可用于表示值**。此外，**对象在被引用时，具有特定的类型**

![1769615781279.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769615781317.png)

对象通过 **名字** 进行引用，通过名字可以访问对象的值，以及修改对象的值。要使用名字引用对象，就必须先 **声明** 这个名字。声明时需要提供名字的 **类型**，这个类型告诉我们对象的值时什么种类的。例如，`int` 类型的对象包含的是整数值

> [!tip]
> 
> 类型的重要之处在于，如果将表示某一种对象类型的位模式按照另一种对象类型来解释，则可能产生不同的值

例如，数值 $1$，在 IEEE 754 单精度浮点数中是按照位模式 $(3f800000)_{16}$ 表示的。如果将这个位模式解释为整数，那么得到的结果是 $1\ 065\ 353\ 216$。

**变量** 就是对象的一个类型，本质上变量就是一个命名的内存块。既然变量是一个对象，那么变量就应该具有类型。现在，我们来学习各种类型变量的使用

## 2.1 整型变量

下面的语句定义了一个整型变量

```c
int apple_count;
```

这个语句定义了一个 `int` 类型的变量 `apple_count`，该变量包含某个随机的垃圾值。在定义变量时，可以而且应该指定初始值，如下所示

```c
int apple_count = 15;
```

类型 `int` 的大小一般为 $32$ 位，可以存储 $-2147483648 \sim 2147483647$。这可以覆盖大多数使用整数的情形，所以 `int` 类型是最常用的类型。

下面语句定义了 $3$ 个 `int` 类型的变量

```c
int apple_count = 15;
int orange_count = 5;
int total_fruit = apple_count + orange_count;
```

C 语言允许在一个语句中定义和初始化给定类型的多个变量。例如

```c
int foot_count = 2, toe_count = 10, head_count = 1;
```

但是，不建议这样定义变量，最好是一个语句定义一个变量。这样会提高程序的可读性，还可以注释每个变量的用途

例如，下面的示例程序将整型变量的值写入标准输出

```c title="ex2_01.c"
/**
 * ex02_01.c - Writing the value of an integer variable to standard output
 */

#include <stdio.h>

int main(void)
{
    int apple_count = 15;
    int orange_count = 5;
    int total_fruit = apple_count + orange_count;

    printf("The value of apple_count is %d\n", apple_count);
    printf("The value of orange_count is %d\n", orange_count);
    printf("The value of total_fruit is %d\n", total_fruit);
    
    return 0;
}
```

### 2.1.1 有符号整数

下表列出了存储有符号整数的所有基本类型

|类型|C标准|Win16|Win32|Unix32/Win64|Unix64|
|:---|:---:|:---:|:----:|:-----:|:-----:|
|`signed char`|$\ge 8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|
|||||||
|`signed short int`|$\ge16$ 位|$16$ 位|$16$ 位|$16$ 位|$16$ 位|
|||||||
|`signed int`|$\ge16$ 位|$16$ 位|$32$ 位|$32$ 位|$32$ 位|
|||||||
|`signed long int`|$\ge32$位|$32$ 位|$32$ 位|$32$ 位|$64$ 位|
|||||||
|`signed long long int`|$\ge64$位|$64$位|$64$位|$64$位|$64$位|


类型 `signed char` 在 C 标准中至少占用 $8$ 位，然而，几乎所有的 C 语言实现都将其实现为 $8$ 位。其他类型占用内存取决于具体实现。在 C 标准库 `<limits.h>` 定义了各种数据类型的取值范围。

大多数时候，`signed` 修饰符是可选的；如果忽略修饰符，默认情形下是带符号的。`char` 是唯一的例外，它是否带符号取决于编译器具体实现

> [!tip]
>
> 在需要强调某个变量是带符号整数时，一般情况需要带上 `signed` 修饰符

此外，除非是单独的 `int` 类型，`int` 关键字也是可选的。换句话说，`signed`、`signed int` 和 `int` 是完全等价的

> [!tip]
>
> 在计算机世界中，只有整数才区分 **有符号整数** 和 **无符号整数**。因此，`signed` 修饰符一出现，就表明这是一个整数类型，默认情况下就是 `int` 类型

### 2.1.2 无符号整数

当然，有时候不需要存储负数。例如，班级的学生数、人类的年龄等，都是不需要存储负数的。无符号整数类型只需要将修饰符 `signed` 替换为 `unsigned` 即可。每个无符号整数类型都不同于有符号整数类型，但是占用的内存大小相同

|类型|C标准|Win16|Win32|Unix32/Win64|Unix64|
|:---|:---:|:---:|:----:|:-----:|:-----:|
|`unsigned char`|$\ge 8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|
|||||||
|`unsigned short int`|$\ge16$ 位|$16$ 位|$16$ 位|$16$ 位|$16$ 位|
|||||||
|`unsigned int`|$\ge16$ 位|$16$ 位|$32$ 位|$32$ 位|$32$ 位|
|||||||
|`unsigned long int`|$\ge32$位|$32$ 位|$32$ 位|$32$ 位|$64$ 位|
|||||||
|`unsigned long long int`|$\ge64$位|$64$位|$64$位|$64$位|$64$位|

### 2.1.3 零值初始化

定义变量时，我们应该将变量进行初始化。然而，并非任何时候都知道变量的初始化。此时，应该选择一个对程序允许没有任何影响的值，$0$ 通常是一个不错的选择。

```c
int counter = 0;
```

> [!tip]
>
> 对于任何基本类型，都可以使用 **零值初始化**。

### 2.1.4 只读变量

有时候，我们希望变量在初始化之后就不在修改，即具有固定值或值不变的变量。在变量定义中使用 `const` 关键字，就可以定义不能修改的变量。这种变量称为 **只读变量**，或 **运行时常量**

```c
const unsigned toe_count {10};
```

关键字 `const` 告诉编译，变量 `toe_count` 不允许修改。任何尝试修改 `toe_count` 的语句都会在编译期间标记为错误。


## 2.2 整型字面值

**字面值** 是直接以具体数据形式（字面意思）书写的固定值，无需变量存储即可使用。它是一种不可更改的常量，如整数 $10$、浮点数 $3.14$、字符 `'A'` 或字符串 `"Hello"`，**直接表示数值本身**

### 2.2.1 十进制整型字面值

在 C 语言中，十进制整数字面值的词法规则如下

```c
["-" "+"]("1" ... "9")("0" .... "9")*["L" "U" "LL" "UL" "ULL"]
[可选符号](非零十进制数码)(十进制数码)*[可选后缀]
```

符号 `-` 和 `+` 决定整数字面值的正负，默认情况下为正数。除开可选的符号外，十进制整数字面值的第一个数码必须为非零数码，随后跟随任意个十进制数码。可选的后缀用于指定字面值的类型


| 后缀  	| 类型          	|
|:-------	|:---------------	|
| `U`   	| `unsigned int`  	|
| `L`   	| `long int`      	|
| `LL`  	| `long long int` 	|
| `UL`      |`unsigned long int`|
| `ULL`     |`unsigned long long int`|

下面列出了一些合法的十进制整数字面值的例子

```c
-123    +123    123    22333    98U    -1234LL    12345ULL     
```

在使用整数字面值初始化变量时，它必须位于变量能类型允许的范围内，否则编译器可能会发出警告

```c
// 符合初始化准则
unsigned long age = 99UL;
unsigned short price = 10;
// 违反初始化准则
unsigned char high = 513U;
unsigned int high = -1;  
```

> [!warning] 
> 
> 对于一个没有后缀的十进制整数字面值，编译器是如何确定其类型的呢？
>
> 编译器按顺序尝试 `int -> long int -> long long int`，直到找到能够存储并且尺寸最小的类型就是该字面值的类型

### 2.2.2 十六进制整型字面值

在 C 语言中，十六进制整数字面值的词法规则如下

```c
["-" "+"] "0" ("x" | "X")("0" .... "9" "A" ... "F")+["L" "U" "LL" "UL" "ULL"]
[可选符号](0x|0X)(十六进制数码)+[可选后缀]
```

下面列出了一些合法的十六进制整数字面值的例子

```c
十六进制字面值:     0x1AF   0x123U  0xAL    0xcad   0xFF
十进制字面值:       431     291U    10L     3245    255
```

十六进制整型字面值主要用于定义位的特定模式。因为每个十六进制数码对应 $4$ 位，所以很容易把位的特定模式表达为十六进制的字面值

例如，程序中表示 RGB 色域中的一个颜色时，常常表示为 $32$ 位字的低 $3$ 字节。白色可以表示 `0xFFFFFF`

### 2.2.3 八进制整型字面值

还可以把整型字面值表示为八进制形式。C 语言中，八进制整数字面值的词法规则如下

```c
["-" "+"] "0" ("0" .... "7")+["L" "U" "LL" "UL" "ULL"]
[可选符号](0)(八进制数码)+[可选后缀]
```

下面列出了八进制整数字面值的例子

```c
八进制字面值:  0657    0443U    012L    06255   0x377
十进制字面值:  431     291U     10L     3245    255
```

### 2.2.4 二进制整型字面值

从 C23 标准开始，整数字面值支持使用二进制形式。其二进制整数字面值的词法规则如下

```c
["-" "+"] "0" ("b" | "B")("0" | "1")+["L" "U" "LL" "UL" "ULL"]
[可选符号](0b|0B)(二进制数码)+[可选后缀]
```

下面列出了二进制整数字面值的例子

```c
二进制字面值:  0B110101111    0b100100011U    01010L
十进制字面值:  431            291U            10L    
```

> [!tip]
>
> 编译器并不在意程序员使用何种形式的字面值，因为这些字面值最终都会转化为相同的位模式存储在内存中。表示整数时使用什么进制取决于是否方便

## 2.3 算术运算符

**运算** 是由运算符定义，例如，运算符 `+` 用于相加，`*` 用于相乘。运算符操作的数值称为 **操作数**。**表达式** 就是由操作数与运算符组成序列。例如，表达式 `2 * 3`，操作数是 $2$ 和 $3$，运算符 `*` 需要两个操作数，所以它称为 **二元运算符**。只需要一个操作数的运算符称为 **一元运算符**，例如表达式 `-width`，表示对操作数 `width` 的符号取反

下表列出了可以对整数进行的算术运算

|运算符|描述|
|:----|:---|
|`+`|加法，表达式 `a + b` 的值是两个操作数的和|
|`-`|减法，表达式 `a - b` 的值是两个操作数的差|
|`*`|乘法，表达式 `a * b` 的值是两个操作数的乘积|
|`/`|除法，表达式 `a / b` 的值是两个操作数的商|
|`%`|模运算，表达式 `a % b` 的值等于 `a - (a / b) * b` |


这些算术运算符会按照我们期望的方式执行。然而，如果运算符 `/` 的两个操作数都是整数（整数除法）时，需要特别注意，其结果依旧是整数。换句话说，**表达式 `a / b` 的含义就是 `a` 中有多少个 `b`**。例如，表达式 `5 / 2` 的结果是 `2`，因为 $5$ 中包含 $2$ 个完整的 $2$。运算符 `%` 是对整数除法的补充。**表达式 `a % b` 的值就是表达式 `a - （a / b）* b` 的结果**

> [!tip]
>
> 也就是说，C 语言的编译器是按照公式 $r = a - \lfloor \frac{a}{b} \rfloor \times b$ 计算余数。其中 `r` 表示余数，`a` 表示被除数，`b` 表示除数
>
> 请注意，这个规则是从 C99 标准起引入。在 C99 标准之前并没有这样规定，而是由实现定义。

运算符 `/` 和 `%` 的右操作数如果为零，则表达式的结果是 **未定义** 的，换句话说，具体结果将取决于你的编译器和计算机架构

### 2.3.1 优先级

在同一个表达式中，如果出现多个运算符，那个运算符先执行是由 **运算符的优先级** 来决定的。算术运算符中，乘法运算符(`*`)、除法运算符(`/`) 和 模运算符(`%`) 总是先于加法运算符(`+`)和减法运算符(`-`)。

> [!tip]
>
> 我们应该了解每个运算符的优先级，但是不必记忆。因为我们总是可以添加圆括号从而保证某个运算符先执行。
>

```c
long width = 4;
long length = 5;
long area = width * length;             // 结果是 20
long perimeter = 2 * width + 2 * length;    // 结果是 18
```

可以使用括号控制更复杂表达式的执行顺序。例如，我们可以编写如下计算周长值的语句

```c
long perimeter = (width + length) * 2;
```

这条语句中的圆括号控制加法运算符先于乘法运算符执行，如果省略的圆括号，则乘法运算符先于加法运算符执行，因为乘法运算符的优先级高于加法运算符。

```c
long perimter = width + length * 2;
```

括号可以嵌套使用，在这种情况下，括号之间的子表达式将按顺序执行，从最内层的括号对到最外层的括号。这个包含嵌套括号的表达式示例将展示它是如何工作的

```c
2 * (a + 3 * (b + 4 * (c + 5 * d)))
```

首先计算表达式 `5 * d`，并将 `c` 加到结果中。将结果乘以 $4$，并将 `b` 加到结果中。将结果乘以 $3$，并将 `a` 加到结果中。最后，将结果乘以 $2$，得到完整表达式的结果

### 2.3.2 结合性

表达式中包含多个相同优先级的运算符时，如果没有圆括号，则运算符的执行顺序由 **运算符的结合性** 决定。大部分运算符都具有 **左结合性**，即 **运算符从左到右计算**；当然，部分运算符具有 **有结合性**，即 **运算符从右向左计算**

> [!tip]
>
> 算术运算符都是左结合的

## 2.4 赋值运算符

在 C 中，变量的值只有在使用 `const` 限定符时才是固定的。在所有其他情况下，变量的值始终可以用新值覆盖

```c
long perimeter = 0;

// ... 其他语句

perimeter = (width + length) * 2;  // 赋值语句
```

> [!tip]
>
> 在 C 语言中，赋值是运算符。一般而言，我们不希望运算符修改操作数的值。如果运算符执行过程中修改了操作数的值，那么称该运算符具有 **副作用**
>
> 换句话说，C 语言中的赋值是表达式，它的值就是赋值给左操作数的值，其副作用使得左操作数的值发生改变

还可以在一条语句中为多个变量进行赋值。例如

```c
int a, b, c = 5, d = 4;

a = b = c *c - d * d;
```

请注意，赋值运算符是**右结合**的，也就是说上述语句按照如下顺序执行

```c
a = (b = (c *c - d * d));
// 首先，计算表达式 c *c - d * d 的值
// 然后，计算表达式 b = c *c - d * d 的值，其副作用是修改左操作数的值
// 最后，计算表达式 a = b 的值
```

下面的示例程序演示了赋值运算符和算术运算符的使用

```c title="ex02_02.c"
/**
 * ex02_02.c - 距离转换程序
 * 
 * 输入 y 码(yard) f 英尺(foot) i 英寸(inche)。输出 xxx 英寸
 * 
 * 注意: 1 yard = 3 feet;   1 foot = 12 inches
**/

#include <stdio.h>

int main(void)
{
    // 声明三个变量，分别存储 y 码 f 英尺 i 英寸
    int yards = 0, feet = 0, inches = 0; 
    printf("Enter three intager for yards、feet、inches: ");
    scanf("%d%*c%d%*c%d", &yards, &feet, &inches);

    const unsigned feet_per_yard = 3;
    const unsigned inches_per_foot = 12;

    // 将  y 码(yard) f 英尺(foot) i 英寸(inche) 转换为英寸(inches)
    unsigned total_inches = 0;
    total_inches = inches + feet * inches_per_foot + yards * feet_per_yard * inches_per_foot;
    printf("This distance corresponds to %d inches.\n", total_inches);

    printf("Enter a distance in inches: ");
    scanf("%d%*c", &total_inches);

    // 将 m 英寸(inches) 转换为 y 码(yard) f 英尺(foot) i 英寸(inche)
    feet = total_inches / inches_per_foot;  // inches => feet
    inches = total_inches % inches_per_foot;  // total_inches - (feet * inches_per_foot)
    yards = feet / feet_per_yard;  // feet => yards
    feet = feet % feet_per_yard;
    printf("This distance corresponds to %d yards %d feet %d inches.", yards, feet, inches);
}
```

### 2.4.1 增强赋值运算符

赋值运算符可以与算术运算符组合起来，形成一个全新的运算符，称为 **增强赋值运算符**

例如，我们在 `ex02_02.c` 中的语句 `feet = feet % feet_per_yard;` 可以使用增强赋值运算符替换，替换后的语句如下

```c
feet %= feet_per_yard;
```

运算符 `%=` 称为增强赋值运算符，也称为 **复合赋值运算符**。其一般形式如下

```c
lhs op= rhs;
```

`lhs` 是左操作数，必须是一个可寻址的对象，用于存储该运算符的结果。`rhs` 是一个右操作数，它可以是任意的表达式。这等价于

```c
lhs = lhs op (rhs); // 注意 rhs 两边的圆括号是不允许被省略
```

注意 **`rhs` 两边的圆括号是不允许被省略**。下面的例子明显说明了不能省略的原因

```c
y *= x + 1;
// 等价于
y = y * (x + 1);
```

在这个示例中，如果省略的圆括号，`y` 中存储的值就是 `y * x + 1`，这不是我们期望的结果

C 语言中的许多运算符都有增强赋值的形式，后续会完整的介绍

## 2.5 sizeof 运算符

`sizeof` 运算符是 C 语言中特殊的运算符，它用于获取表达式或类型占用的字节数。

```c
#include <stdio.h>

int main()
{
    int height = 74;

    printf("sizeof height: %lu bytes.\n", sizeof height);
    printf("sizeof(long long): %lu bytes.\n", sizeof(long long));
    printf("sizeof(height * height / 2): %lu bytes.\n", sizeof(height * height / 2));
}
```

> [!tip]
>
> 使用 `sizeof` 运算符时，总是应该给 `sizeof` 表达式加上括号，这样是没有任何坏处的

`sizeof` 运算符返回结果的类型是 `size_t`，它在标准头文件 `<stddef.h>` 中定义，本质上是一个无符号整数。类型 `size_t` 由实现定义，在程序中我们应该使用 `size_t` 作为类型名，这样对于所有的实现都是通用的

## 2.6 整数的递增和递减

**自增**（加 1）和 **自减**（减 1）是整数变量的两种运算。一般情况下，我们可以通过增强赋值运算符 `+=` 和 `-=` 完成，然而，C 语言为这两个操作提供了另外的运算符，分别自增运算符 `++` 和自减运算符 `--`。这两个运算符是一元运算符，通常用于整数变量

> [!tip]
>
> 显然，运算符 `++` 和 `--` 会修改其操作数的值，因此它们也是具有副作用的

运算符 `++` 和 `--` 在 `for` 语句会经常使用。下面 $3$ 条语句都是用于修改 `cout` 变量的值

```c
int count = 5;
count = count + 1; 
count += 1;
++count;
```

这 $3$ 条语句的作用完全相同，每一条语句都会给变量 `count` 递增 $1$。显然，使用运算符 `++` 的形式最简单。并且，运算符 `++` 是直接操作数的值。上述三个表达式的值就是递增变量的值，在表达式中使用已递增的值。如果变量 `count` 的值是 $5$，则执行下面的语句

```c
total = ++count + 6;
```

请注意，运算符 `++` 和 `--` 的优先级高于表达式中其二元运算符，因此，`count` 的值先递增为 $6$。再计算等号右边表达式的值，所有变量 `total` 的值是 $12$

> [!tip]
>
> 运算符 `++` 和 `--` 还可以作为后缀形式使用，即运算符位于操作数的后边。但是，不建议这样做。

在使用运算符 `++` 和 `--` 的后缀形式时，先在表达式中使用变量的值进行计算，再递增该变量的值。例如，表达式 `count++` 的值是递增前变量 `count` 的值

```c
total = (count++) + 6;
```

假设 `count` 的值还是 $5$，但是表达式 `count++` 的值是 $5$，因此 `total` 的值是 $5 + 6 = 11$。因此，上面的语句是等价于下面的两条语句

```c
total = count + 6;
++count;
```

> [!warning]
>
> 尽量不要在表达式中出现 `a++ + b`，甚至是 `a+++b` 这样的表达式，因为其含义是不明确的。编译器可能无法分析我们想要执行的操作。因此，我们必须使用 `(a++) + b` 这样明确的表达式


## 2.7 定义浮点变量

有时候我们希望使用非整数值，尤其在处理极大数和极小数时，可以使用 **浮点类型** 的变量。C 语言提供了 $3$ 种浮点类型，如下表所示

|类型|描述|
|:---|:---|
|`float`|单精度浮点数|
|`double`|双精度浮点数|
|`long double`|扩展双精度浮点数|

> [!warning]
>
> 请注意，一定不能使用 `signed` 和 `unsigned` 关键字来修饰浮点类型。根据 [第一章 入门#浮点数编码](./001-入门.md#163-浮点数编码) 中内容，浮点数应该总是带符号的

C 标准并未规定这些浮点类型采用什么样的浮点数编码。然而，几乎所有的编译器和计算机架构都采用 [第一章 入门#浮点数编码](./001-入门.md#163-浮点数编码) 中介绍的浮点编码

通常，`float` 类型提供 $7$ 位有效数字（十进制）的精度（尾数为 $23$ 位），`double` 类型提供几乎是 $16$ 位有效数字的精度（尾数为 $52$ 位），而 `long double` 类型提供了 $18$ 位有效数字进度（尾数为 $64$ 位）

## 2.8 浮点数字面值

浮点数字面量，例如 `3.14` 或 `1.5`，表示 **实数的近似值**。在 C 语言中，浮点数字面值词法规则定义如下

```c
// 形式1
["+" | "-"]("0" ... "9")+ "." [("0" ... "9")+] [("e" | "E") ["+" | "-"] ("0" ... "9")+] ["F" | "L"]
// 形式2
"." ("0" ... "9")+ [("e" | "E") ["+" | "-"] ("0" ... "9")+] ["F" | "L"]
// 形式3
["+" | "-"]("0" ... "9")+ ("e" | "E") ["+" | "-"] ("0" ... "9")+ ["F" | "L"]
```

下面给出了一些浮点数字面值的

```c
// 形式1
2.71828    4.0    10.    1.005e4    -0.1E-3L
// 形式2 
.001   .345e1F
// 形式3
5E3
```

在浮点数字面值中，形如 `5E3` 或 `1.005e4` 形式的字面值称为 **指数形式**，表示的是 $10$ 的幂乘以该值。换句话说，$5E3 = 5 \times 10^3 = 5000.0$。指数形式的字面值通常用于表示非常大或非常小的数。

请注意，对于不带后缀的浮点数字面值，其类型为 `double`。如果需要指定浮点数字面值的类型，可以添加后缀。其中 `F` 表示 `float` 类型，而 `L` 表示 `long double` 类型。

## 2.9 浮点数运算

除了算术运算符 `%` 的操作数不能是浮点数之外，其他算术运算符的操作数都可以是浮点数。例如

```c
const double pi = 3.141592653589793;
double a = 0.2;
double z = 9;
double volume = 0;
volume = pi * z * z * a;
```

> [!tip]
>
> 请注意，运算符 `++` 和 `--` 的操作数也可以是浮点数，此时它们将会使操作数增加或减少 $1.0$。当然，尽量不要在浮点类型的变量上使用 `++` 和 `--` 运算符

### 2.9.1 数学函数

C 标准头文件 `<math.h>` 中提供了一些常用数学函数，这些数学函数通常接收浮点类型的参数。下表列出了一些常用的数学函数

|                   函数                    |                   描述|
|:-----------------------------------------|:---------------------|
|`double acos(double x)`                    |返回以弧度表示的 `x` 的反余弦|
|`double asin(double x)`                    |返回以弧度表示的 `x` 的反正弦|
|`double atan(double x)`                    |返回以弧度表示的 `x` 的反正切|
|`double atan2(double y, double x)`         |返回以弧度表示的 `y/x` 的反正切。`y` 和 `x` 的值的符号决定了正确的象限|
|`double cos(double x)`                     |返回弧度角 `x` 的余弦|
|`double cosh(double x)`                    |返回 `x` 的双曲余弦|
|`double sin(double x)`                     |返回弧度角 `x` 的正弦|
|`double sinh(double x)`                    |返回 `x` 的双曲正弦|
|`double tanh(double x)`                    |返回 `x` 的双曲正切|
|`double exp(double x)`                     |返回 `e` 的 `x` 次幂的值|
|`double frexp(double x, int *exponent)`    |把浮点数 `x` 分解成尾数和指数. `x = mantissa * 2 ^ exponent`|
|`double ldexp(double x, int exponent)`     |返回 `x` 乘以 `2` 的 `exponent` 次幂|
|`double log(double x)`                     |返回 `x` 的自然对数（基数为 e 的对数）|
|`double log10(double x)`                   |返回 `x` 的常用对数（基数为 10 的对数）|
|`double modf(double x, double *integer)`   |返回 `x` 的小数部分，并设置 `integer` 为整数部分|
|`double pow(double x, double y)`           |返回 `x` 的 `y` 次幂。|
|`double sqrt(double x)`                    |返回 `x` 的平方根|
|`double ceil(double x)`                    |返回大于或等于 `x` 的最小的整数值|
|`double fabs(double x)`                    |返回 `x` 的绝对值|
|`double floor(double x)`                   |返回小于或等于 `x` 的最大的整数值|
|`double fmod(double x, double y)`          |返回 `x` 除以 `y` 的余数|

下面是使用浮点数的一个示例程序。在这个示例程序中，我们通过 [牛顿法](https://en.wikipedia.org/wiki/Newton%27s_method) 计算任意正浮点数的平方根

```c title="ex02_03.c"
/** 
 * 
 * ex02_03.c - 使用 牛顿法 计算任意正浮点数的平方根
 * 
 * 参考资料
 * + https://en.wikipedia.org/wiki/Newton%27s_method
 *
 * 牛顿法基本步骤
 * 1. 选择一个接近函数 f(x) 的零点 x0
 * 2. 计算 f(x0) 和 f'(x0)
 * 3. 计算穿过点 (x0, f(x0)) 并且斜率为 f'(x0) 的直线与 x 轴交点的坐标
 *      0 = (x - x0) f'(x0) + f(x0)
 * 4. 得到的 x 坐标命名为 x1。这个 x1 就会比 x0 更接近 f(x) = 0 的解。因此，利用 x1 继续迭代
 * 
 * 迭代公式为
 * x_{n+1} = x_n - f(x_{n}) / f'(x_{n})
**/


#include <stdio.h>
#include <math.h>

/**
 * 使用牛顿法计算平方根。
 * 
 * x^2 = m  =>  f(x) = x^2 - m  => f(x) 的零点
 * 
 * x_{n+1} = x_{n} - f(x_{n}) / f'(x_{n})
 * x_{n+1} = x_{n} - (x_{n}^2 - m) / (2 * x_{n})
**/
double NewtonSqrt(const double m)
{
    const double err = 1e-8;
    if (m < 0) 
    {
        return -1.0;
    }
    double result = m;
    // 如果原值减去近似根的平方大于误差，继续循环
    while (fabs(m - result * result) >= err)
    {
        result = result - (result * result - m) / (2.0 * result);
    }
    return result;
}

int main(void)
{
    printf("%lf", NewtonSqrt(2));
}
```

### 2.9.2 无效的浮点结果

根据 C 标准，除以 $0$ 的结果是不确定的。尽管在大多数计算机上，硬件的浮点操作都是根据 IEEE 754 binary 标准实现的。因此，在把浮点数除以 $0$ 的时候，编译器一般会表现出类似的行为。IEEE 754 binary 浮点标准定义了几个特殊值，请参阅 [第一章 入门#浮点数编码](./001-入门.md#163-浮点数编码) 

下表列出了所有无效浮点数结果的可能。表中的 `value` 是任意非零值

|操作|结果||操作|结果|
|:---:|:---:|---|:---:|:---:|
|$\pm \text{value} / 0$|$\pm \text{infinity}$||$0 / 0$|$\text{NaN}$|
|$\pm \text{infinity} \pm value$|$\pm \text{infinity}$||$\pm \text{infinity} / \pm \text{infinity}$|$\text{NaN}$|
|$\pm \text{infinity} * value$|$\pm \text{infinity}$||$\pm \text{infinity} / - \text{infinity}$|$\text{NaN}$|
|$\pm \text{infinity} / value$|$\pm \text{infinity}$||$\pm \text{infinity} / * 0$|$\text{NaN}$|

## 2.10 隐式类型转换

表达式中可以包含不同类型的操作数。然而，二元运算符要求两个操作数具有相同的类型。如果它们的类型不同，编译器就必须将其中一个操作数的类型转换为另一个操作数的类型。这种由编译器执行的类型转换称为 **隐式类型转换**，其工作方式是**把值域较小的变量转换为另一个变量的类型**。

在操作数不同的表达式中，编译器选择把值域更小的操作数转换另一个操作数的类型。实际上，它按照下面的顺序从高到低进行排序

|等级|类型||等级|类型||等级|类型|
|:---|:---|---|:---|:---|---|:---|:---|
|$1$|`long double`||$4$|`unsigned long long`||$7$|`long`|
|$2$|`double`||$5$|`long long`||$8$|`unsigned int`|
|$3$|`float`||$6$|`unsigned long`||$9$|`int`|

要转换的操作数是位置较低的类型。因此，在处理 `long long` 类型和 `unsigned int` 类型的操作中，`unsigned int` 类型的操作数被转换为 `long long` 类型。

> [!tip]
>
> 请注意：任何值域小于 `int` 类型的操作数都会被转换为 `int` 类型

隐式类型转换可能会产生意想不到的结果。例如，下面的示例程序

```c
#include <stdio.h>
#include <stdbool.h>

int main()
{
    unsigned int x = 20u;
    int y = 30;
    bool flag = x - y < 0; 
    printf("%s\n", flag ? "true":"false"); 
}
```

在这个示例程序中，`flag` 的正确结果应该 `true`，然而，最终输出的结果却是 `false`。这是因为 `y` 的值被转换为了 `unsigned int` 类型，所以减法的结果应该也是 `unsigned int` 类型。由于 `unisgned int` 类型无法表示 $-10$

对于 $n$ 位的无符号整型，如果 $m, m < 0$，则其无符号表示的结果为 $2^{n} - m$。这种的现象称为 **下溢**

与之对应且相反的现象，即 **上溢**。对于 $n$ 位的无符号整数类型，如果 $m, m > 2^{n}$，则其无符号表示结果为 $m \% 2^{n}$。例如，$8$ 位无符号整数表示 $258$ 的结果就是 $258 \% 256 = 2$

> [!warning]
>
> 请注意：只有无符号整数的上溢和下溢的结果是确定的。如果是有符号整数，发生溢出时，其结果是不确定的，取决于编译器和目标计算机架构

对于赋值运算符，如果左操作数类型与右操作数类型不同，编译器会将右操作数的转换为左操作数类型的值

```c
int y = 0;
double z = 2.5;
y = z; // 窄化类型转换
```

> [!warning]
>
> 当值域较大的类型向值域较小的类型转换时，可能会发生精度丢失的问题，这被称为 **窄化类型转换**。编译应该禁止这种类型转换，至少也应该发出告警

## 2.11 显式类型转换

隐式类型转换转换有时候往往并不会向我们期待的那样进行。在这种时候，我们应该告知编译器操作数的类型。这种由程序员指定类型的转换称为 **显式类型转换**

在 C 语言中使用运算符 `(type)expression` 进行显式类型转换，其中 `type` 是目标类型。例如

```c
inches = (unsigned int) (length * inches_per_yard) % inches_per_foot;
```

## 2.12 使用字符变量

`char` 类型的变量主要用于存储单个字符的编码，占用 $1$ 字节的内存。C 标准并没有指定用于表示基本字符的字符编码，原则上这由特定的编译器指定，但是一般使用 [ASCII 编码](001-入门.md#ascii)。下面的示例代码声明了几个 `char` 类型的变量并初始化

```c
char letter;     // 未初始化，垃圾值
char yes = 'y';  // 使用字符字面值初始化
char ch = 33;    // 使用字符编码初始化
```

字符类型的字面值使用 **单引号** 标记，它可以用于初始化 `char` 类型的变量。同时，也可以直接使用字符的编码（整数）进行初始化，注意，必须保证整数在 `char` 类型的值域范围内。`char` 是否带符号取决于具体的编译器实现

> [!tip]
>
> 请注意，对于采用 ASCII 编码作为基本字符集的编译器，`char` 类型的字面值只能是 ASCII 字符，并且单引号之间只能有一个字符。

在 ASCII 字符集中存在一个非打印字符，这些字符不能通过键盘直接输入。为了能够输入这些字符，C 标准中定义了一些列的 **转义字符序列** 来表示这些非打印字符。转义字符序列还有一个作用就是让 C 语法规则使用的特殊字符失去特殊含义

下表列出了常用的转义字符序列

|转义字符序列|描述||转义字符序列|描述||转义字符序列|描述|
|:---|:---|---|:---|:---|---|:---|:---|
|`\n`|换行符(LF)||`\r`|回车符(CR)||`\t`|水平制表符(TAB)|
|`\v`|垂直制表符(VT)||`\a`|响铃(BEL)||`\b`|退格符(BS)|
|`\f`|换页符(FF)||`\\`|反斜杠||`\'`|单引号|
|`\"`|双引号||`\?`|问号|

非打印字符非常多，C 标准只定义了少数的转义字符。为了能够表示所有字符，C 标准定义了 **编码转义字符序列**，我们可以使用字符的编码输入任何字符。目前，可以使用的编码字符转义序列有两种形式，分别是 **八进制** 和 **十六进制**。

> [!tip]
>
> 序列 `\ooo` 表示一个八进制值为 `ooo` 的字符，这种形式称为 **八进制字符编码转义序列**。对于 `char` 类型的字符，最大的八进制字符编码转义序列为 `\377`
>
> 序列 `\xhh` 表示一个十六进制值为 `hh` 的字符，这种程序称为 **十六进制字符编码序列**

## 2.13 auto 关键字

从 C23 标准开始，关键字 `auto` 用于自动类型推导。换句话说，使用 `auto` 关键字声明的标识符能够自动推断类型。例如

```c
auto a = 10;   // 推断 a 的类型是 int
auto b = 10u;  // 推断 a 的类型是 unsigned int
```

> [!tip]
>
> 在 C 语言种，`auto` 关键字的作用并不大。
