# 第二章 基本数据类型

在 [第一章 入门](./001-入门.md) 中我们学习了 C 语言的基本构成要素。其中，最基本的要素就是 **对象**，即 **表示值的一块存储区域**。更准确的说，**执行环境中数据存储区域，其内容可用于表示值**。此外，**对象在被引用时，具有特定的类型**

![1769615781279.png](https://fastly.jsdelivr.net/gh/duyupeng36/images@master/2026-01/1769615781317.png)

对象通过 **名字** 进行引用，通过名字可以访问对象的值，以及修改对象的值。要使用名字引用对象，就必须先 **声明** 这个名字。声明时需要提供名字的 **类型**，这个类型告诉我们对象的值时什么种类的。例如，`int` 类型的对象包含的是整数值

> [!tip]
> 
> 类型的重要之处在于，如果将表示某一种对象类型的位模式按照另一种对象类型来解释，则可能产生不同的值

例如，数值 $1$，在 IEEE 754 单精度浮点数中是按照位模式 $(3f800000)_{16}$ 表示的。如果将这个位模式解释为整数，那么得到的结果是 $1\ 065\ 353\ 216$。

**变量** 就是对象的一个类型，本质上变量就是一个命名的内存块。既然变量是一个对象，那么变量就应该具有类型。现在，我们来学习各种类型变量的使用

## 2.1 整型变量

下面的语句定义了一个整型变量

```c
int apple_count;
```

这个语句定义了一个 `int` 类型的变量 `apple_count`，该变量包含某个随机的垃圾值。在定义变量时，可以而且应该指定初始值，如下所示

```c
int apple_count = 15;
```

类型 `int` 的大小一般为 $32$ 位，可以存储 $-2147483648 \sim 2147483647$。这可以覆盖大多数使用整数的情形，所以 `int` 类型是最常用的类型。

下面语句定义了 $3$ 个 `int` 类型的变量

```c
int apple_count = 15;
int orange_count = 5;
int total_fruit = apple_count + orange_count;
```

C 语言允许在一个语句中定义和初始化给定类型的多个变量。例如

```c
int foot_count = 2, toe_count = 10, head_count = 1;
```

但是，不建议这样定义变量，最好是一个语句定义一个变量。这样会提高程序的可读性，还可以注释每个变量的用途

例如，下面的示例程序将整型变量的值写入标准输出

```c title="ex2_01.c"
/**
 * ex02_01.c - Writing the value of an integer variable to standard output
 */

#include <stdio.h>

int main(void)
{
    int apple_count = 15;
    int orange_count = 5;
    int total_fruit = apple_count + orange_count;

    printf("The value of apple_count is %d\n", apple_count);
    printf("The value of orange_count is %d\n", orange_count);
    printf("The value of total_fruit is %d\n", total_fruit);
    
    return 0;
}
```

### 2.1.1 有符号整数

下表列出了存储有符号整数的所有基本类型

|类型|C标准|Win16|Win32|Unix32/Win64|Unix64|
|:---|:---:|:---:|:----:|:-----:|:-----:|
|`signed char`|$\ge 8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|
|||||||
|`signed short int`|$\ge16$ 位|$16$ 位|$16$ 位|$16$ 位|$16$ 位|
|||||||
|`signed int`|$\ge16$ 位|$16$ 位|$32$ 位|$32$ 位|$32$ 位|
|||||||
|`signed long int`|$\ge32$位|$32$ 位|$32$ 位|$32$ 位|$64$ 位|
|||||||
|`signed long long int`|$\ge64$位|$64$位|$64$位|$64$位|$64$位|


类型 `signed char` 在 C 标准中至少占用 $8$ 位，然而，几乎所有的 C 语言实现都将其实现为 $8$ 位。其他类型占用内存取决于具体实现，要求尺寸必须是 `signed char` 类型的整数整数倍

大多数时候，`signed` 修饰符是可选的；如果忽略修饰符，默认情形下是带符号的。`char` 是唯一的例外，它是否带符号取决于编译器具体实现

> [!tip]
>
> 在需要强调某个变量是带符号整数时，一般情况需要带上 `signed` 修饰符

此外，除非是单独的 `int` 类型，`int` 关键字也是可选的。换句话说，`signed`、`signed int` 和 `int` 是完全等价的

> [!tip]
>
> 在计算机世界中，只有整数才区分 **有符号整数** 和 **无符号整数**。因此，`signed` 修饰符一出现，就表明这是一个整数类型，默认情况下就是 `int` 类型

### 2.1.2 无符号整数

当然，有时候不需要存储负数。例如，班级的学生数、人类的年龄等，都是不需要存储负数的。无符号整数类型只需要将修饰符 `signed` 替换为 `unsigned` 即可。每个无符号整数类型都不同于有符号整数类型，但是占用的内存大小相同

|类型|C标准|Win16|Win32|Unix32/Win64|Unix64|
|:---|:---:|:---:|:----:|:-----:|:-----:|
|`unsigned char`|$\ge 8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|$8$ 位|
|||||||
|`unsigned short int`|$\ge16$ 位|$16$ 位|$16$ 位|$16$ 位|$16$ 位|
|||||||
|`unsigned int`|$\ge16$ 位|$16$ 位|$32$ 位|$32$ 位|$32$ 位|
|||||||
|`unsigned long int`|$\ge32$位|$32$ 位|$32$ 位|$32$ 位|$64$ 位|
|||||||
|`unsigned long long int`|$\ge64$位|$64$位|$64$位|$64$位|$64$位|

### 2.1.3 零值初始化

定义变量时，我们应该将变量进行初始化。然而，并非任何时候都知道变量的初始化。此时，应该选择一个对程序允许没有任何影响的值，$0$ 通常是一个不错的选择。

```c
int counter = 0;
```

> [!tip]
>
> 对于任何基本类型，都可以使用 **零值初始化**。

### 2.1.4 只读变量

有时候，我们希望变量在初始化之后就不在修改，即具有固定值或值不变的变量。在变量定义中使用 `const` 关键字，就可以定义不能修改的变量。这种变量称为 **只读变量**，或 **运行时常量**

```c
const unsigned toe_count {10};
```

关键字 `const` 告诉编译，变量 `toe_count` 不允许修改。任何尝试修改 `toe_count` 的语句都会在编译期间标记为错误。


## 2.2 整型字面值

**字面值** 是直接以具体数据形式（字面意思）书写的固定值，无需变量存储即可使用。它是一种不可更改的常量，如整数 $10$、浮点数 $3.14$、字符 `'A'` 或字符串 `"Hello"`，**直接表示数值本身**

### 2.2.1 十进制整型字面值

在 C 语言中，十进制整数字面值的词法规则如下

```c
["-" "+"]("1" ... "9")("0" .... "9")*["L" "U" "LL" "UL" "ULL"]
[可选符号](非零十进制数码)(十进制数码)*[可选后缀]
```

符号 `-` 和 `+` 决定整数字面值的正负，默认情况下为正数。除开可选的符号外，十进制整数字面值的第一个数码必须为非零数码，随后跟随任意个十进制数码。可选的后缀用于指定字面值的类型


| 后缀  	| 类型          	|
|:-------	|:---------------	|
| `U`   	| `unsigned int`  	|
| `L`   	| `long int`      	|
| `LL`  	| `long long int` 	|
| `UL`      |`unsigned long int`|
| `ULL`     |`unsigned long long int`|

下面列出了一些合法的十进制整数字面值的例子

```c
-123    +123    123    22333    98U    -1234LL    12345ULL     
```

在使用整数字面值初始化变量时，它必须位于变量能类型允许的范围内，否则编译器可能会发出警告

```c
// 符合初始化准则
unsigned long age = 99UL;
unsigned short price = 10;
// 违反初始化准则
unsigned char high = 513U;
unsigned int high = -1;  
```

> [!warning] 
> 
> 对于一个没有后缀的十进制整数字面值，编译器是如何确定其类型的呢？
>
> 编译器按顺序尝试 `int -> long int -> long long int`，直到找到能够存储并且尺寸最小的类型就是该字面值的类型

### 2.2.2 十六进制整型字面值

在 C 语言中，十六进制整数字面值的词法规则如下

```c
["-" "+"] "0" ("x" | "X")("0" .... "9" "A" ... "F")+["L" "U" "LL" "UL" "ULL"]
[可选符号](0x|0X)(十六进制数码)+[可选后缀]
```

下面列出了一些合法的十六进制整数字面值的例子

```c
十六进制字面值:     0x1AF   0x123U  0xAL    0xcad   0xFF
十进制字面值:       431     291U    10L     3245    255
```

十六进制整型字面值主要用于定义位的特定模式。因为每个十六进制数码对应 $4$ 位，所以很容易把位的特定模式表达为十六进制的字面值

例如，程序中表示 RGB 色域中的一个颜色时，常常表示为 $32$ 位字的低 $3$ 字节。白色可以表示 `0xFFFFFF`

### 2.2.3 八进制整型字面值

还可以把整型字面值表示为八进制形式。C 语言中，八进制整数字面值的词法规则如下

```c
["-" "+"] "0" ("0" .... "7")+["L" "U" "LL" "UL" "ULL"]
[可选符号](0)(八进制数码)+[可选后缀]
```

下面列出了八进制整数字面值的例子

```c
八进制字面值:  0657    0443U    012L    06255   0x377
十进制字面值:  431     291U     10L     3245    255
```

### 2.2.4 二进制整型字面值

从 C23 标准开始，整数字面值支持使用二进制形式。其二进制整数字面值的词法规则如下

```c
["-" "+"] "0" ("b" | "B")("0" | "1")+["L" "U" "LL" "UL" "ULL"]
[可选符号](0b|0B)(二进制数码)+[可选后缀]
```

下面列出了二进制整数字面值的例子

```c
二进制字面值:  0B110101111    0b100100011U    01010L
十进制字面值:  431            291U            10L    
```

> [!tip]
>
> 编译器并不在意程序员使用何种形式的字面值，因为这些字面值最终都会转化为相同的位模式存储在内存中。表示整数时使用什么进制取决于是否方便

## 2.3 算术运算符

**运算** 是由运算符定义，例如，运算符 `+` 用于相加，`*` 用于相乘。运算符操作的数值称为 **操作数**。**表达式** 就是由操作数与运算符组成序列。例如，表达式 `2 * 3`，操作数是 $2$ 和 $3$，运算符 `*` 需要两个操作数，所以它称为 **二元运算符**。只需要一个操作数的运算符称为 **一元运算符**，例如表达式 `-width`，表示对操作数 `width` 的符号取反

下表列出了可以对整数进行的算术运算

|运算符|描述|
|:----|:---|
|`+`|加法，表达式 `a + b` 的值是两个操作数的和|
|`-`|减法，表达式 `a - b` 的值是两个操作数的差|
|`*`|乘法，表达式 `a * b` 的值是两个操作数的乘积|
|`/`|除法，表达式 `a / b` 的值是两个操作数的商|
|`%`|模运算，表达式 `a % b` 的值等于 `a - (a / b) * b` |


这些算术运算符会按照我们期望的方式执行。然而，如果运算符 `/` 的两个操作数都是整数（整数除法）时，需要特别注意，其结果依旧是整数。换句话说，**表达式 `a / b` 的含义就是 `a` 中有多少个 `b`**。例如，表达式 `5 / 2` 的结果是 `2`，因为 $5$ 中包含 $2$ 个完整的 $2$。运算符 `%` 是对整数除法的补充。**表达式 `a % b` 的值就是表达式 `a - （a / b）* b` 的结果**

> [!tip]
>
> 也就是说，C 语言的编译器是按照公式 $r = a - \lfloor \frac{a}{b} \rfloor \times b$ 计算余数。其中 `r` 表示余数，`a` 表示被除数，`b` 表示除数
>
> 请注意，这个规则是从 C99 标准起引入。在 C99 标准之前并没有这样规定，而是由实现定义。

运算符 `/` 和 `%` 的右操作数如果为零，则表达式的结果是 **未定义** 的，换句话说，具体结果将取决于你的编译器和计算机架构

### 优先级

在同一个表达式中，如果出现多个运算符，那个运算符先执行是由 **运算符的优先级** 来决定的。算术运算符中，乘法运算符(`*`)、除法运算符(`/`) 和 模运算符(`%`) 总是先于加法运算符(`+`)和减法运算符(`-`)。

> [!tip]
>
> 我们应该了解每个运算符的优先级，但是不必记忆。因为我们总是可以添加圆括号从而保证某个运算符先执行。
>

```c
long width = 4;
long length = 5;
long area = width * length;             // 结果是 20
long perimeter = 2 * width + 2 * length;    // 结果是 18
```

可以使用括号控制更复杂表达式的执行顺序。例如，我们可以编写如下计算周长值的语句

```c
long perimeter = (width + length) * 2;
```

这条语句中的圆括号控制加法运算符先于乘法运算符执行，如果省略的圆括号，则乘法运算符先于加法运算符执行，因为乘法运算符的优先级高于加法运算符。

```c
long perimter = width + length * 2;
```

括号可以嵌套使用，在这种情况下，括号之间的子表达式将按顺序执行，从最内层的括号对到最外层的括号。这个包含嵌套括号的表达式示例将展示它是如何工作的

```c
2 * (a + 3 * (b + 4 * (c + 5 * d)))
```

首先计算表达式 `5 * d`，并将 `c` 加到结果中。将结果乘以 $4$，并将 `b` 加到结果中。将结果乘以 $3$，并将 `a` 加到结果中。最后，将结果乘以 $2$，得到完整表达式的结果

### 结合性

表达式中包含多个相同优先级的运算符时，如果没有圆括号，则运算符的执行顺序由 **运算符的结合性** 决定。大部分运算符都具有 **左结合性**，即 **运算符从左到右计算**；当然，部分运算符具有 **有结合性**，即 **运算符从右向左计算**

> [!tip]
>
> 算术运算符都是左结合的

## 2.4 赋值运算符

在 C 中，变量的值只有在使用 `const` 限定符时才是固定的。在所有其他情况下，变量的值始终可以用新值覆盖

```c
long perimeter = 0;

// ... 其他语句

perimeter = (width + length) * 2;  // 赋值语句
```

> [!tip]
>
> 在 C 语言中，赋值是运算符。一般而言，我们不希望运算符修改操作数的值。如果运算符执行过程中修改了操作数的值，那么称该运算符具有 **副作用**
>
> 换句话说，C 语言中的赋值是表达式，它的值就是赋值给左操作数的值，其副作用使得左操作数的值发生改变

还可以在一条语句中为多个变量进行赋值。例如

```c
int a, b, c = 5, d = 4;

a = b = c *c - d * d;
```

请注意，赋值运算符是**右结合**的，也就是说上述语句按照如下顺序执行

```c
a = (b = (c *c - d * d));
// 首先，计算表达式 c *c - d * d 的值
// 然后，计算表达式 b = c *c - d * d 的值，其副作用是修改左操作数的值
// 最后，计算表达式 a = b 的值
```

下面的示例程序演示了赋值运算符和算术运算符的使用

```c title="ex02_02.c"
/**
 * ex02_02.c - 距离转换程序
 * 
 * 输入 y 码(yard) f 英尺(foot) i 英寸(inche)。输出 xxx 英寸
 * 
 * 注意: 1 yard = 3 feet;   1 foot = 12 inches
**/

#include <stdio.h>

int main(void)
{
    // 声明三个变量，分别存储 y 码 f 英尺 i 英寸
    int yards = 0, feet = 0, inches = 0; 
    printf("Enter three intager for yards、feet、inches: ");
    scanf("%d%*c%d%*c%d", &yards, &feet, &inches);

    const unsigned feet_per_yard = 3;
    const unsigned inches_per_foot = 12;

    // 将  y 码(yard) f 英尺(foot) i 英寸(inche) 转换为英寸(inches)
    unsigned total_inches = 0;
    total_inches = inches + feet * inches_per_foot + yards * feet_per_yard * inches_per_foot;
    printf("This distance corresponds to %d inches.\n", total_inches);

    printf("Enter a distance in inches: ");
    scanf("%d%*c", &total_inches);

    // 将 m 英寸(inches) 转换为 y 码(yard) f 英尺(foot) i 英寸(inche)
    feet = total_inches / inches_per_foot;  // inches => feet
    inches = total_inches % inches_per_foot;  // total_inches - (feet * inches_per_foot)
    yards = feet / feet_per_yard;  // feet => yards
    feet = feet % feet_per_yard;
    printf("This distance corresponds to %d yards %d feet %d inches.", yards, feet, inches);
}
```

### 增强赋值运算符

赋值运算符可以与算术运算符组合起来，形成一个全新的运算符，称为 **增强赋值运算符**

例如，我们在 `ex02_02.c` 中的语句 `feet = feet % feet_per_yard;` 可以使用增强赋值运算符替换，替换后的语句如下

```c
feet %= feet_per_yard;
```

运算符 `%=` 称为增强赋值运算符，也称为 **复合赋值运算符**。其一般形式如下

```c
lhs op= rhs;
```

`lhs` 是左操作数，必须是一个可寻址的对象，用于存储该运算符的结果。`rhs` 是一个右操作数，它可以是任意的表达式。这等价于

```c
lhs = lhs op (rhs); // 注意 rhs 两边的圆括号是不允许被省略
```

注意 **`rhs` 两边的圆括号是不允许被省略**。下面的例子明显说明了不能省略的原因

```c
y *= x + 1;
// 等价于
y = y * (x + 1);
```

在这个示例中，如果省略的圆括号，`y` 中存储的值就是 `y * x + 1`，这不是我们期望的结果

C 语言中的许多运算符都有增强赋值的形式，后续会完整的介绍

## 2.5 sizeof 运算符

`sizeof` 运算符是 C 语言中特殊的运算符，它用于获取表达式或类型占用的字节数。

```c
#include <stdio.h>

int main()
{
    int height = 74;

    printf("sizeof height: %lu bytes.\n", sizeof height);
    printf("sizeof(long long): %lu bytes.\n", sizeof(long long));
    printf("sizeof(height * height / 2): %lu bytes.\n", sizeof(height * height / 2));
}
```

> [!tip]
>
> 使用 `sizeof` 运算符时，总是应该给 `sizeof` 表达式加上括号，这样是没有任何坏处的

`sizeof` 运算符返回结果的类型是 `size_t`，它在标准头文件 `<stddef.h>` 中定义，本质上是一个无符号整数。类型 `size_t` 由实现定义，在程序中我们应该使用 `size_t` 作为类型名，这样对于所有的实现都是通用的

## 2.6 整数的递增和递减

**自增**（加 1）和 **自减**（减 1）是整数变量的两种运算。一般情况下，我们可以通过增强赋值运算符 `+=` 和 `-=` 完成，然而，C 语言为这两个操作提供了另外的运算符，分别自增运算符 `++` 和自减运算符 `--`。这两个运算符是一元运算符，通常用于整数变量

> [!tip]
>
> 显然，运算符 `++` 和 `--` 会修改其操作数的值，因此它们也是具有副作用的

运算符 `++` 和 `--` 在 `for` 语句会经常使用。下面 $3$ 条语句都是用于修改 `cout` 变量的值

```c
int count = 5;
count = count + 1; 
count += 1;
++count;
```

这 $3$ 条语句的作用完全相同，每一条语句都会给变量 `count` 递增 $1$。显然，使用运算符 `++` 的形式最简单。并且，运算符 `++` 是直接操作数的值。上述三个表达式的值就是递增变量的值，在表达式中使用已递增的值。如果变量 `count` 的值是 $5$，则执行下面的语句

```c
total = ++count + 6;
```

请注意，运算符 `++` 和 `--` 的优先级高于表达式中其二元运算符，因此，`count` 的值先递增为 $6$。再计算等号右边表达式的值，所有变量 `total` 的值是 $12$

> [!tip]
>
> 运算符 `++` 和 `--` 还可以作为后缀形式使用，即运算符位于操作数的后边。但是，不建议这样做。

在使用运算符 `++` 和 `--` 的后缀形式时，先在表达式中使用变量的值进行计算，再递增该变量的值。例如，表达式 `count++` 的值是递增前变量 `count` 的值

```c
total = (count++) + 6;
```

假设 `count` 的值还是 $5$，但是表达式 `count++` 的值是 $5$，因此 `total` 的值是 $5 + 6 = 11$。因此，上面的语句是等价于下面的两条语句

```c
total = count + 6;
++count;
```

> [!waring]
>
> 尽量不要在表达式中出现 `a++ + b`，甚至是 `a+++b` 这样的表达式，因为其含义是不明确的。编译器可能无法分析我们想要执行的操作。因此，我们必须使用 `(a++) + b` 这样明确的表达式


